classdef ImgProcessing
    methods(Static)        
        function void = processData(dataLoaderL,folderName)
            %Metodo para procesar las imagenes, recibe un dataset, lo
            %recorre y obtiene cada imagen para procesarla.
            %folderName es el nombre de la carpeta en la que se va a guardar
            %la informacion e.g. 'SATELLITE_1'
            
            %Se carga la carpeta en la que estan las imagenes como un DataSet
            datastore = dataLoaderL;

            %Podemos ir leyendo y aplicandole el proceso a las imagenes una a una.
            %len = dataLoaderL.size;
            len = datastore.size;
            
            %Creacion de csv para exportar datos
            csv = [];

            for i =1:len
                node = datastore.getElement(i);
                imgPath = node.Data.imagePath;
                a = imread(imgPath);

                [vegetationIndex, maskedRGBImage,~,maskedKImage] = rotateCropAndProcess(a);
                
                fileName = split(info.Filename, filesep);
                fileName = fileName(end);    
                str = split(fileName, '_');
                date = char(str(4));
                date = insertAfter(date,4,'-');
                date = insertAfter(date,7,'-');
                record = [date fileName vegetationIndex];
                csv = [csv; record];
                
                %Dependiendo de como este implementado quitar el char()
                FILENAME = ['..' filesep 'Data' filesep folderName filesep 'kmeans' filesep char(fileName)];
                imwrite(maskedKImage,FILENAME);

                FILENAME = ['..' filesep 'Data' filesep folderName filesep 'thresholding' filesep char(fileName)];          
                imwrite(maskedRGBImage,FILENAME);
            end
            writecell(csv,['..' filesep 'Data' filesep folderName filesep 'data.txt']);
        end
        
        function [vegetationIndex, maskedRGBImage,RGB,maskedKImage] = rotateCropAndProcess(a)
            %Esta funcion rota, corta, y llama a create mask para que
            %procese la imagen
            %Retorna: El numero de pixeles de vegetacion(OR entre mascara
            %verde de K-means y mascara de threshold) en vegetationIndex,
            %la imagen con la mascara del treshlod aplicaeda en
            %maskedRGBIMage. La ROI en RGB. La imagen con la mascara verde
            %de k-mena aplicada en maskedKImage
            
            b = imrotate(a,12, 'crop');
            auxR = 1.0e+03*[2.8, 4, 5.9-2.8, 7.1-4];
            b = imcrop(b,auxR);
            [~,maskedRGBImage,RGB,maskedKImage, ~,vegetationIndex, ~, ~, ~, ~, ~] = createMaskV2(b);

        end

        function [BW,maskedRGBImage,RGB, maskedKImage,maskedFinalImage,greenPN, n, b,k3c1,k3c2,k3c3] = createMaskV2(RGB)
            %Funcion que 
            %  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
            %  auto-generated code from the colorThresholder app. The colorspace and
            %  range for each channel of the colorspace were set within the app. The
            %  segmentation mask is returned in BW, and a composite of the mask and
            %  original RGB images is returned in maskedRGBImage.

            % Auto-generated by colorThresholder app on 17-Nov-2020
            %------------------------------------------------------
        

            % Convert RGB image to chosen color space
            I = rgb2lab(RGB);

            % Define thresholds for channel 1 based on histogram settings
            channel1Min = 46.585;
            channel1Max = 67.300;

            % Define thresholds for channel 2 based on histogram settings
            channel2Min = -49.958;
            channel2Max = -9.489;

            % Define thresholds for channel 3 based on histogram settings
            channel3Min = -22.600;
            channel3Max = 56.834;

            % Create mask based on chosen histogram thresholds
            sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
                (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
                (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
            BW = sliderBW;

            % Initialize output masked image based on input image.
            maskedRGBImage = RGB;

            % Set background pixels where BW is false to zero.
            maskedRGBImage(repmat(~BW,[1 1 3])) = 0;


            %Take only a* and b* channel
            ab = I(:,:,2:3);
            ab = im2single(ab);
            %Funcion para aplicar segmentacion mediante kmeans
            % Repeat the clustering 3 times to avoid local minima
            k3 = imsegkmeans(ab,3,'NumAttempts',3);

            %Apply different k3 labels as mask
            mask1 = k3==1;
            k3c1 = RGB .* uint8(mask1);
            mask2 = k3==2;
            k3c2 = RGB .* uint8(mask2);
            mask3 = k3==3;
            k3c3 = RGB .* uint8(mask3);

            %Choose the greenest k-label
            [i, n, b] = greenest(k3c1,k3c2,k3c3);
            switch i
                case 1
                    maskedKImage = k3c1;
                    mask = mask1;
                case 2
                    maskedKImage = k3c2;
                    mask = mask2;
                case 3
                    maskedKImage = k3c3;
                    mask = mask3;
            end

            finalMask = or(mask,BW);
            maskedFinalImage = RGB;
            maskedFinalImage(repmat(~finalMask,[1 1 3])) = 0;
            greenPN= sum(finalMask,'all');
        end
        
        function NewCharArray = insertAfter( CharArray, Position, WhatToInsert)
            %funcion auxiliar para menejo de strings
          NewCharArray = char( strcat( cellstr(CharArray(:,1:Position)), cellstr(WhatToInsert), cellstr(CharArray(:, Position+1:end)) ) );
        end
        
        function [i, n, b] = greenest(k3c1,k3c2,k3c3)
            %Retorna el indicde de la imagen con mayor cantidad dde verde 
            %de las ingresadas
            %n y b para debuig
                        
            %Threshold para vegetacion
            channel1Min = 46.585;
            channel1Max = 67.300;
            channel2Min = -49.958;
            channel2Max = -9.489;
            channel3Min = -22.600;
            channel3Max = 56.834;

            %Threshold para nubes
            badChannel1Min = 64.857;
            badChannel1Max = 85.027;
            badChannel2Min = -37.999;
            badChannel2Max = -13.807;
            badChannel3Min = -8.828;
            badChannel3Max = 1.678;

            %Aplicar ventana deslizante(nubes y vegetacion) y obtener suma 
            I = rgb2lab(k3c1);
            sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
                (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
                (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
            n1 = sum(sliderBW,'all');
            sliderBad = (I(:,:,1) >= badChannel1Min ) & (I(:,:,1) <= badChannel1Max) & ...
                (I(:,:,2) >= badChannel2Min ) & (I(:,:,2) <= badChannel2Max) & ...
                (I(:,:,3) >= badChannel3Min ) & (I(:,:,3) <= badChannel3Max);
            b1 = sum(sliderBad,'all');

            I = rgb2lab(k3c2);
            sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
                (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
                (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
            n2 = sum(sliderBW,'all');
            sliderBad = (I(:,:,1) >= badChannel1Min ) & (I(:,:,1) <= badChannel1Max) & ...
                (I(:,:,2) >= badChannel2Min ) & (I(:,:,2) <= badChannel2Max) & ...
                (I(:,:,3) >= badChannel3Min ) & (I(:,:,3) <= badChannel3Max);
            b2 = sum(sliderBad,'all');

            I = rgb2lab(k3c3);
            sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
                (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
                (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
            n3 = sum(sliderBW,'all');
            sliderBad = (I(:,:,1) >= badChannel1Min ) & (I(:,:,1) <= badChannel1Max) & ...
                (I(:,:,2) >= badChannel2Min ) & (I(:,:,2) <= badChannel2Max) & ...
                (I(:,:,3) >= badChannel3Min ) & (I(:,:,3) <= badChannel3Max);
            b3 = sum(sliderBad,'all');

            %Array de indice de vegetacion
            n = [n1, n2, n3];

            %Array de indice de nubes verdosas
            b = [b1, b2, b3];

            [~, i] = max(n);
            [maxB,iB] = max(b);
            %Control de caso en el que hay mas nubes que vegetacion
            if i == iB && maxB ~= 0
                n(i) = -n(i);
                [~, i] = max(n);
            end
        end
        
    end
end

