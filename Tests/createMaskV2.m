function [BW,maskedRGBImage,RGB, maskedKImage,maskedFinalImage,greenPN, n, b,k3c1,k3c2,k3c3] = createMaskV2(RGB)
% function [BW,maskedRGBImage,RGB, lab, k3c1, k3c2, k3c3, k4c1, k4c2, k4c3, k4c4] = createMaskV2(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 17-Nov-2020
%------------------------------------------------------
%Aqui no deberiamos recortar nada
%Entra imagen X completa en RGB, se transforma a LAB
%Hay que verificar nivel de nubosidad
% Si es muy nubosa-> chao
% Si no
%     Calcular todas las cosas
%     Obtener el numero de pixeles verde
%     or entre mask y 

% Convert RGB image to chosen color space
I = rgb2lab(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 46.585;
channel1Max = 67.300;

% Define thresholds for channel 2 based on histogram settings
channel2Min = -49.958;
channel2Max = -9.489;

% Define thresholds for channel 3 based on histogram settings
channel3Min = -22.600;
channel3Max = 56.834;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;


%Take only a* and b* channel
ab = I(:,:,2:3);
ab = im2single(ab);
%Funcion para aplicar segmentacion mediante kmeans
% Repeat the clustering 3 times to avoid local minima
k3 = imsegkmeans(ab,3,'NumAttempts',3);

%Apply different k3 labels as mask
mask1 = k3==1;
k3c1 = RGB .* uint8(mask1);
mask2 = k3==2;
k3c2 = RGB .* uint8(mask2);
mask3 = k3==3;
k3c3 = RGB .* uint8(mask3);

%Choose the greenest k-label
[i, n, b] = greenest(k3c1,k3c2,k3c3);
switch i
    case 1
        maskedKImage = k3c1;
        mask = mask1;
    case 2
        maskedKImage = k3c2;
        mask = mask2;
    case 3
        maskedKImage = k3c3;
        mask = mask3;
end

finalMask = or(mask,BW);
maskedFinalImage = RGB;
maskedFinalImage(repmat(~finalMask,[1 1 3])) = 0;
greenPN= sum(finalMask,'all');


end
